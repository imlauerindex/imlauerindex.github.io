<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Error de Segmentación (Segmentation Fault) en C | Index</title>
<meta name="robots" content='index, follow'>
<meta name="description" content="">
<meta name="generator" content="hugo-index">
<link crossorigin="anonymous" href="https://imlauerindex.github.io/assets/stylesheet.css" rel="preload stylesheet" as="style">
<script crossorigin="anonymous" src="https://imlauerindex.github.io/assets/quicklink.js" rel="preload" as="script"></script>
<script>
    window.addEventListener('load', () => {
        quicklink.listen();
    });
</script>

  </head>
  <body><header>
  <h1>
    <a href="https://imlauerindex.github.io/">
      <img src="https://imlauerindex.github.io/index.png" alt="Index">
      <span>Index</span>
    </a>
    <span class="hl">/</span>
    <a href="https://imlauerindex.github.io/segmentation_fault_in_c/">
      <span>Error de Segmentación (Segmentation Fault) en C</span>
    </a>
  </h1>
  <p class="desc"></p>
</header>
<div class="main">

<ul class="tagsList single">
  
  <li><a href="https://imlauerindex.github.io/@c/">C</a></li>
  
  <li><a href="https://imlauerindex.github.io/@programacion/">Programacion</a></li>
  
</ul>

<div class="content"><h3 id="escenarios-comunes-de-fallas-de-segmentación">Escenarios comunes de fallas de segmentación</h3>
<p>En una falla de segmentación, un programa intenta acceder a una memoria a la que no está autorizado o que no existe. Algunos escenarios comunes que pueden causar fallas de segmentación son:</p>
<ol>
<li>Modificar una cadena de solo lectura</li>
<li>Acceder a una dirección que está liberada</li>
<li>Acceder a límites de índice fuera de la matriz</li>
<li>Uso inadecuado de scanf()</li>
<li>Desbordamiento de pila</li>
<li>Desreferenciación de puntero no inicializado</li>
</ol>
<h4 id="1-modificar-una-cadena-de-sólo-lectura">1. Modificar una cadena de sólo lectura</h4>
<p>Los literales de cadena se almacenan en la sección de solo lectura de la memoria. Es por eso que el siguiente programa puede fallar (da un error de segmentación) porque la línea *(str+1) = &rsquo;n&rsquo; intenta escribir una memoria de solo lectura.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Programa de C para demostrar error de segmento (segmentation fault)
</span></span></span><span class="line"><span class="cl"><span class="c1">// modificando una cadena de sólo lectura
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Se almacena en la parte de solo lectura del segmento de datos
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">str</span> <span class="o">=</span> <span class="s">&#34;GfG&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Problema: intentando modificar memoria de sólo lectura
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="2-acceder-a-una-dirección-liberada">2. Acceder a una dirección liberada</h3>
<p>Aquí, en el siguiente código, se elimina la referencia al puntero p después de liberar el bloque de memoria, lo cual no está permitido por el compilador. Estos punteros se denominan punteros colgantes y producen fallos de segmento o terminaciones anormales del programa en tiempo de ejecución.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Programa C para demostrar el error de segmentación
</span></span></span><span class="line"><span class="cl"><span class="c1">// Accediendo a una dirección que está liberada
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#incluir &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#incluir &lt;stdlib.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// asignando memoria a p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// se libera el espacio asignado a p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// core dump/segmentation fault
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">110</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="3-acceder-al-índice-de-matriz-fuera-de-límites">3. Acceder al índice de matriz fuera de límites</h4>
<p>En C y C++, acceder a un índice de matriz fuera de límites puede provocar un error de segmentación u otro comportamiento indefinido. No hay verificación de límites para matrices en C y C++. Aunque en C++, el uso de contenedores, como con el método std::vector::at() o con una declaración if(), puede evitar errores fuera de límite.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// programa C para demostrar la segmentación
</span></span></span><span class="line"><span class="cl"><span class="c1">// falla cuando se accede a la matriz fuera de límite.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#incluir &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Accediendo fuera de límites
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="4-uso-inadecuado-de-scanf">4. Uso inadecuado de scanf()</h4>
<p>La función scanf() espera la dirección de una variable como entrada. Aquí, en este programa, n toma un valor de 2 y asume que su dirección es 1000. Si pasamos n a scanf(), la entrada obtenida de STDIN se coloca en la memoria 2 no válida, que debería ser 1000. Esto provoca daños en la memoria y provoca un error de segmentación.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Programa C para demostrar la segmentación
</span></span></span><span class="line"><span class="cl"><span class="c1">// error cuando se pasa valor a scanf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#incluir &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="5-desbordamiento-de-pila">5. Desbordamiento de pila</h4>
<p>No es un problema relacionado con el puntero, incluso es posible que el código no tenga un solo puntero. Es por quedarse sin memoria en la pila. También es un tipo de corrupción de memoria que puede ocurrir debido a un gran tamaño de matriz, una gran cantidad de llamadas recursivas, muchas variables locales, etc.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Programa en C para ilustrar el
</span></span></span><span class="line"><span class="cl"><span class="c1">// error de segmentación debido a
</span></span></span><span class="line"><span class="cl"><span class="c1">// desbordamiento de pila
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#incluir &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2000000000</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="6-desbordamiento-del-búfer">6. Desbordamiento del búfer</h4>
<p>Si los datos que se almacenan en el búfer son mayores que el tamaño asignado del búfer, se produce un desbordamiento del búfer que provoca un error de segmentación. La mayoría de los métodos en lenguaje C no realizan verificación de límites, por lo que el desbordamiento del búfer ocurre con frecuencia cuando olvidamos asignar el tamaño requerido al búfer.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Programa en C para ilustrar el
</span></span></span><span class="line"><span class="cl"><span class="c1">// fallo de segmentación debido a
</span></span></span><span class="line"><span class="cl"><span class="c1">// desbordamiento del buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#incluir &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">ref</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Esta es una cadena larga&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sscanf</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="7-desreferenciar-un-puntero-null-o-no-inicializado">7. Desreferenciar un puntero NULL o no inicializado</h4>
<p>Es un error de programación común eliminar la referencia a un puntero no inicializado (puntero salvaje), lo que puede dar como resultado un comportamiento indefinido. Cuando se utiliza un puntero en un contexto que lo trata como un puntero válido y accede a su valor subyacente, aunque no se haya inicializado para apuntar a una ubicación de memoria válida, se produce este error. Esto puede provocar daños en los datos, errores de programa o fallos de segmentación. Dependiendo de su entorno y estado al eliminar la referencia, los punteros no inicializados pueden producir resultados diferentes.</p>
<p>Como sabemos, el puntero NULL no apunta a ninguna ubicación de memoria, por lo que eliminar la referencia resultará en un error de segmentación.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Programa C para demostrar la segmentación
</span></span></span><span class="line"><span class="cl"><span class="c1">// error cuando el puntero no está inicializado
</span></span></span><span class="line"><span class="cl"><span class="c1">// se accede
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#incluir &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">nptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d %d&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">nptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></div></div><footer>
    <hr>
    <div class="footer-text">
        <div>© 2024 Index</div>
        <div>Powered by <a href="https://gohugo.io/">Hugo</a> & <a
                href="https://github.com/adityatelange/hugo-index/">Index</a></div>
    </div>
</footer>
</body>
</html>
